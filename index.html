<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Web Flasher - Flash Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 30px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }

        .section-title {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
            color: #667eea;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title::before {
            content: "‚óè";
            font-size: 0.8em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #495057;
        }

        select, input[type="text"], input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
            text-align: center;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .progress-container {
            margin-top: 20px;
            display: none;
        }

        .progress-container.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 40px;
            background: #e9ecef;
            border-radius: 20px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 1.1em;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255,255,255,0.3),
                transparent
            );
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-message {
            margin-top: 15px;
            text-align: center;
            color: #495057;
            font-weight: 600;
            font-size: 1.05em;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .progress-details {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #6c757d;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
        }

        .alert.active {
            display: block;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            padding: 12px;
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-input-label:hover {
            border-color: #667eea;
            background: #e9ecef;
        }

        .file-name {
            margin-top: 10px;
            color: #667eea;
            font-weight: 500;
        }

        .serial-status {
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }

        .serial-status.active {
            display: block;
        }

        .serial-status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .serial-status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .monitor-section {
            margin-top: 30px;
        }

        .monitor-container {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .monitor-line {
            color: #d4d4d4;
            margin-bottom: 2px;
            word-wrap: break-word;
        }

        .monitor-line.error {
            color: #f48771;
        }

        .monitor-line.success {
            color: #4ec9b0;
        }

        .monitor-line.info {
            color: #569cd6;
        }

        .monitor-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .monitor-input {
            flex: 1;
            padding: 10px;
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
        }

        .monitor-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-small {
            padding: 10px 20px;
            font-size: 0.9em;
        }

        .monitor-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            font-size: 0.85em;
            color: #6c757d;
        }

        .monitor-stats span {
            padding: 5px 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 15px;
            }

            .content {
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .btn-group {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ ESP32 Web Flasher</h1>
            <p>Flash ESP32 tr·ª±c ti·∫øp t·ª´ tr√¨nh duy·ªát - Kh√¥ng c·∫ßn c√†i ƒë·∫∑t!</p>
        </div>

        <div class="content">
            <!-- Serial Connection Section -->
            <div class="section">
                <div class="section-title">K·∫øt n·ªëi Serial</div>
                <div id="serialStatus" class="serial-status"></div>
                <div class="form-group">
                    <label for="baud">Baud Rate:</label>
                    <select id="baud">
                        <option value="115200" selected>115200</option>
                        <option value="230400">230400</option>
                        <option value="460800">460800</option>
                        <option value="921600">921600</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="connectSerial()" id="connectBtn">
                        üîå K·∫øt n·ªëi Serial
                    </button>
                    <button class="btn btn-primary" onclick="disconnectSerial()" id="disconnectBtn" style="display: none;">
                        üîå Ng·∫Øt k·∫øt n·ªëi
                    </button>
                </div>
                <div class="alert alert-warning" id="browserWarning" style="display: none;">
                    <strong>‚ö†Ô∏è L∆∞u √Ω:</strong> Web Serial API ch·ªâ ho·∫°t ƒë·ªông tr√™n Chrome, Edge, Opera v√† c√°c tr√¨nh duy·ªát Chromium. 
                    C·∫ßn k·∫øt n·ªëi HTTPS ho·∫∑c localhost.
                </div>
            </div>

            <!-- Flash Firmware Section -->
            <div class="section">
                <div class="section-title">Flash Firmware</div>
                <div class="form-group">
                    <label for="firmwareFile">Ch·ªçn file firmware (.bin):</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="firmwareFile" accept=".bin" onchange="onFileSelect()">
                        <label for="firmwareFile" class="file-input-label">
                            üìÅ Click ƒë·ªÉ ch·ªçn file ho·∫∑c k√©o th·∫£ file v√†o ƒë√¢y
                        </label>
                    </div>
                    <div id="fileName" class="file-name"></div>
                </div>
                <div class="form-group">
                    <label for="address">ƒê·ªãa ch·ªâ Flash (hex):</label>
                    <input type="text" id="address" value="0x1000" placeholder="0x1000">
                </div>
                <div class="form-group">
                    <label for="flashMode">Flash Mode:</label>
                    <select id="flashMode">
                        <option value="qio">QIO</option>
                        <option value="qout">QOUT</option>
                        <option value="dio" selected>DIO</option>
                        <option value="dout">DOUT</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="flashSize">Flash Size:</label>
                    <select id="flashSize">
                        <option value="256KB">256KB</option>
                        <option value="512KB">512KB</option>
                        <option value="1MB">1MB</option>
                        <option value="2MB">2MB</option>
                        <option value="4MB" selected>4MB</option>
                        <option value="8MB">8MB</option>
                        <option value="16MB">16MB</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="flashFreq">Flash Frequency:</label>
                    <select id="flashFreq">
                        <option value="80m">80MHz</option>
                        <option value="60m">60MHz</option>
                        <option value="48m">48MHz</option>
                        <option value="40m" selected>40MHz</option>
                        <option value="30m">30MHz</option>
                        <option value="26m">26MHz</option>
                        <option value="24m">24MHz</option>
                        <option value="20m">20MHz</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="eraseAll" style="width: auto; margin-right: 8px;">
                        X√≥a to√†n b·ªô flash tr∆∞·ªõc khi flash
                    </label>
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="flashFirmware()" id="flashBtn" disabled>
                        ‚ö° Flash Firmware
                    </button>
                </div>
                <div id="flashProgress" class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill">0%</div>
                    </div>
                    <div class="progress-message" id="progressMessage"></div>
                </div>
            </div>

            <!-- Serial Monitor Section -->
            <div class="section monitor-section">
                <div class="section-title">üì∫ Serial Monitor</div>
                <div class="monitor-stats">
                    <span>üìä Lines: <span id="monitorLineCount">0</span></span>
                    <span>üì• Received: <span id="monitorBytesReceived">0</span> bytes</span>
                    <span>üì§ Sent: <span id="monitorBytesSent">0</span> bytes</span>
                </div>
                <div class="monitor-controls">
                    <input type="text" id="monitorInput" class="monitor-input" placeholder="Nh·∫≠p l·ªánh v√† nh·∫•n Enter ƒë·ªÉ g·ª≠i..." onkeypress="handleMonitorKeyPress(event)">
                    <button class="btn btn-primary btn-small" onclick="sendMonitorCommand()">üì§ G·ª≠i</button>
                    <button class="btn btn-primary btn-small" onclick="clearMonitor()">üóëÔ∏è X√≥a</button>
                    <button class="btn btn-primary btn-small" onclick="toggleMonitor()" id="monitorToggleBtn">‚è∏Ô∏è T·∫°m d·ª´ng</button>
                </div>
                <div id="monitorContainer" class="monitor-container">
                    <div class="monitor-line info">Serial Monitor s·∫µn s√†ng. K·∫øt n·ªëi ESP32 ƒë·ªÉ b·∫Øt ƒë·∫ßu...</div>
                </div>
            </div>

            <!-- Alert Messages -->
            <div id="alert" class="alert"></div>
        </div>
    </div>

    <!-- Use official esptool-js library from Espressif -->
    <script src="https://unpkg.com/esptool-js@1.0.0/dist/esptool.js"></script>
    <script src="esptool-wrapper.js"></script>
    <script>
        let port = null;
        let reader = null;
        let writer = null;
        let monitorReading = false;
        let monitorPaused = false;
        let monitorLineCount = 0;
        let monitorBytesReceived = 0;
        let monitorBytesSent = 0;
        let monitorReader = null;

        // Check browser support
        if (typeof navigator !== 'undefined' && !navigator.serial) {
            const warningEl = document.getElementById('browserWarning');
            if (warningEl) {
                warningEl.style.display = 'block';
            }
            // showAlert will be defined later, so we'll call it after DOM is ready
            setTimeout(() => {
                if (typeof showAlert === 'function') {
                    showAlert('Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ Web Serial API. Vui l√≤ng s·ª≠ d·ª•ng Chrome, Edge ho·∫∑c Opera.', 'error');
                }
            }, 100);
        }

        // ESPTool wrapper instance
        let espWrapper = null;

        // Connect to serial port using esptool-js
        async function connectSerial() {
            try {
                if (!navigator.serial) {
                    showAlert('Web Serial API kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ tr√™n tr√¨nh duy·ªát n√†y! Vui l√≤ng d√πng Chrome, Edge ho·∫∑c Opera.', 'error');
                    return;
                }

                // Close existing connection if any
                if (port) {
                    try {
                        if (reader) {
                            await reader.cancel();
                            await reader.releaseLock();
                            reader = null;
                        }
                        if (writer) {
                            await writer.releaseLock();
                            writer = null;
                        }
                        if (port.readable || port.writable) {
                            await port.close();
                        }
                    } catch (e) {
                        console.log('Error closing existing port:', e);
                    }
                    port = null;
                }
                if (espWrapper) {
                    try {
                        await espWrapper.disconnect();
                    } catch (e) {
                        console.log('Error disconnecting wrapper:', e);
                    }
                    espWrapper = null;
                }

                // Request port (this will show browser's port selection dialog)
                addMonitorLine('ƒêang y√™u c·∫ßu ch·ªçn c·ªïng serial...', 'info');
                port = await navigator.serial.requestPort();
                
                const baud = parseInt(document.getElementById('baud').value);
                addMonitorLine(`ƒêang m·ªü c·ªïng v·ªõi baud rate ${baud}...`, 'info');
                
                // Open port
                try {
                    await port.open({ baudRate: baud });
                } catch (e) {
                    if (e.message.includes('already open')) {
                        addMonitorLine('C·ªïng ƒë√£ m·ªü, ti·∫øp t·ª•c...', 'info');
                    } else {
                        throw e;
                    }
                }
                
                // Get readers/writers
                if (!reader && port.readable) {
                    reader = port.readable.getReader();
                }
                if (!writer && port.writable) {
                    writer = port.writable.getWriter();
                }

                // Try to use esptool-js if available, otherwise use direct serial
                if (typeof ESPToolWrapper !== 'undefined') {
                    addMonitorLine('ƒêang kh·ªüi t·∫°o ESPTool wrapper...', 'info');
                    espWrapper = new ESPToolWrapper(port, baud);
                    
                    const connected = await espWrapper.connect((message) => {
                        addMonitorLine(message, 'info');
                    });
                    
                    if (connected) {
                        const chipInfo = espWrapper.getChipInfo();
                        if (chipInfo) {
                            addMonitorLine(`‚úÖ ƒê√£ k·∫øt n·ªëi v·ªõi ${chipInfo.name}`, 'success');
                            if (chipInfo.mac) {
                                addMonitorLine(`üì± MAC: ${chipInfo.mac}`, 'info');
                            }
                        }
                    } else {
                        addMonitorLine('‚ö†Ô∏è K·∫øt n·ªëi c∆° b·∫£n (esptool-js ch∆∞a s·∫µn s√†ng, d√πng Web Serial tr·ª±c ti·∫øp)', 'warning');
                        addMonitorLine('‚úÖ ƒê√£ k·∫øt n·ªëi serial port', 'success');
                    }
                } else if (typeof ESPLoader !== 'undefined') {
                    // Try direct ESPLoader if wrapper not available
                    addMonitorLine('ƒêang kh·ªüi t·∫°o ESPLoader...', 'info');
                    try {
                        // Try different ESPLoader API formats
                        if (typeof ESPLoader === 'function') {
                            espWrapper = new ESPLoader({
                                port: port,
                                baudRate: baud,
                                logFunction: (msg) => addMonitorLine(msg, 'info')
                            });
                            await espWrapper.connect();
                            addMonitorLine('‚úÖ ƒê√£ k·∫øt n·ªëi v·ªõi ESP32', 'success');
                        }
                    } catch (e) {
                        addMonitorLine('‚ö†Ô∏è ESPLoader init failed, using direct serial: ' + e.message, 'warning');
                        addMonitorLine('‚úÖ ƒê√£ k·∫øt n·ªëi serial port', 'success');
                    }
                } else {
                    // Fallback: direct serial connection
                    addMonitorLine('‚ö†Ô∏è esptool-js kh√¥ng kh·∫£ d·ª•ng, s·ª≠ d·ª•ng Web Serial tr·ª±c ti·∫øp', 'warning');
                    addMonitorLine('‚úÖ ƒê√£ k·∫øt n·ªëi serial port', 'success');
                }

                updateSerialStatus(true);
                document.getElementById('connectBtn').style.display = 'none';
                document.getElementById('disconnectBtn').style.display = 'inline-block';
                document.getElementById('flashBtn').disabled = false;
                document.getElementById('eraseBtn').disabled = false;
                
                // Start monitoring
                startMonitor();
                
                showAlert('ƒê√£ k·∫øt n·ªëi th√†nh c√¥ng!', 'success');
            } catch (error) {
                console.error('Connection error:', error);
                addMonitorLine('‚ùå L·ªói k·∫øt n·ªëi: ' + error.message, 'error');
                
                if (error.name === 'NotFoundError') {
                    showAlert('Kh√¥ng t√¨m th·∫•y c·ªïng serial. Vui l√≤ng th·ª≠ l·∫°i.', 'error');
                } else if (error.name === 'SecurityError') {
                    showAlert('L·ªói b·∫£o m·∫≠t: Vui l√≤ng cho ph√©p truy c·∫≠p c·ªïng serial.', 'error');
                } else if (error.name === 'InvalidStateError') {
                    showAlert('C·ªïng serial ƒëang ƒë∆∞·ª£c s·ª≠ d·ª•ng. Vui l√≤ng ƒë√≥ng c√°c ·ª©ng d·ª•ng kh√°c.', 'error');
                } else {
                    showAlert('L·ªói k·∫øt n·ªëi: ' + error.message, 'error');
                }
                
                // Clean up on error
                if (port) {
                    try {
                        await port.close();
                    } catch (e) {}
                    port = null;
                }
            }
        }

        // Disconnect serial port
        async function disconnectSerial() {
            try {
                stopMonitor();
                
                // Close ESPTool wrapper connection first
                if (espWrapper) {
                    try {
                        await espWrapper.disconnect();
                    } catch (e) {
                        console.log('Error disconnecting wrapper:', e);
                    }
                    espWrapper = null;
                }
                
                // Close readers/writers
                if (reader) {
                    try {
                        await reader.cancel();
                    } catch (e) {
                        console.log('Error canceling reader:', e);
                    }
                    try {
                        await reader.releaseLock();
                    } catch (e) {
                        console.log('Error releasing reader:', e);
                    }
                    reader = null;
                }
                if (writer) {
                    try {
                        await writer.releaseLock();
                    } catch (e) {
                        console.log('Error releasing writer:', e);
                    }
                    writer = null;
                }
                
                // Close port
                if (port) {
                    try {
                        // Check if port is still open before closing
                        if (port.readable || port.writable) {
                            await port.close();
                        }
                    } catch (e) {
                        console.log('Error closing port:', e);
                    }
                    port = null;
                }
                
                updateSerialStatus(false);
                document.getElementById('connectBtn').style.display = 'inline-block';
                document.getElementById('disconnectBtn').style.display = 'none';
                document.getElementById('flashBtn').disabled = true;
                document.getElementById('eraseBtn').disabled = true;
                
                addMonitorLine('ƒê√£ ng·∫Øt k·∫øt n·ªëi.', 'info');
                showAlert('ƒê√£ ng·∫Øt k·∫øt n·ªëi.', 'success');
            } catch (error) {
                console.error('Disconnect error:', error);
                showAlert('L·ªói khi ng·∫Øt k·∫øt n·ªëi: ' + error.message, 'error');
                // Force cleanup even on error
                port = null;
                reader = null;
                writer = null;
                espWrapper = null;
            }
        }

        // Update serial status
        function updateSerialStatus(connected) {
            const statusDiv = document.getElementById('serialStatus');
            statusDiv.classList.remove('connected', 'disconnected');
            statusDiv.classList.add(connected ? 'connected' : 'disconnected', 'active');
            statusDiv.textContent = connected ? '‚úÖ ƒê√£ k·∫øt n·ªëi' : '‚ùå Ch∆∞a k·∫øt n·ªëi';
        }

        // Handle file selection
        function onFileSelect() {
            const fileInput = document.getElementById('firmwareFile');
            const fileName = document.getElementById('fileName');
            
            if (fileInput.files.length > 0) {
                fileName.textContent = 'üìÑ ' + fileInput.files[0].name;
            } else {
                fileName.textContent = '';
            }
        }

        // Flash firmware using esptool-js (official library with full logic)
        async function flashFirmware() {
            if (!port || !writer) {
                showAlert('Vui l√≤ng k·∫øt n·ªëi serial tr∆∞·ªõc!', 'error');
                return;
            }

            const fileInput = document.getElementById('firmwareFile');
            if (!fileInput.files.length) {
                showAlert('Vui l√≤ng ch·ªçn file firmware!', 'error');
                return;
            }

            const address = document.getElementById('address').value;
            if (!/^0x[0-9A-Fa-f]+$/.test(address)) {
                showAlert('ƒê·ªãa ch·ªâ flash kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p d·∫°ng hex (v√≠ d·ª•: 0x1000)', 'error');
                return;
            }

            const file = fileInput.files[0];
            const flashMode = document.getElementById('flashMode').value;
            const flashSize = document.getElementById('flashSize').value;
            const flashFreq = document.getElementById('flashFreq').value;
            const eraseAll = document.getElementById('eraseAll').checked;

            try {
                document.getElementById('flashProgress').classList.add('active');
                document.getElementById('flashBtn').disabled = true;
                
                updateProgress(0, 'ƒêang ƒë·ªçc file firmware...');
                addMonitorLine('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                addMonitorLine('B·∫Øt ƒë·∫ßu qu√° tr√¨nh flash firmware...', 'info');
                
                const arrayBuffer = await file.arrayBuffer();
                const firmwareData = new Uint8Array(arrayBuffer);
                
                updateProgress(5, 'ƒê√£ ƒë·ªçc file firmware');
                addMonitorLine(`üìÑ File: ${file.name}`, 'info');
                addMonitorLine(`üì¶ K√≠ch th∆∞·ªõc: ${(firmwareData.length / 1024).toFixed(2)} KB`, 'info');
                addMonitorLine(`üìç ƒê·ªãa ch·ªâ: ${address}`, 'info');
                addMonitorLine(`‚öôÔ∏è Mode: ${flashMode}, Size: ${flashSize}, Freq: ${flashFreq}`, 'info');
                
                // Convert flash parameters to esptool format
                const flashModeMap = { 'qio': 0, 'qout': 1, 'dio': 2, 'dout': 3 };
                const flashSizeMap = {
                    '256KB': 0x12, '512KB': 0x13, '1MB': 0x14, '2MB': 0x15,
                    '4MB': 0x16, '8MB': 0x17, '16MB': 0x18, '32MB': 0x19
                };
                const flashFreqMap = {
                    '80m': 0xf, '60m': 0xe, '48m': 0xd, '40m': 0xc,
                    '30m': 0xb, '26m': 0xa, '24m': 0x9, '20m': 0x8, '16m': 0x7
                };
                
                const flashParams = {
                    flashMode: flashModeMap[flashMode] || 2,
                    flashSize: flashSizeMap[flashSize] || 0x16,
                    flashFreq: flashFreqMap[flashFreq] || 0xc
                };
                
                updateProgress(10, 'ƒêang chu·∫©n b·ªã flash...');
                
                // Erase flash if requested
                if (eraseAll) {
                    updateProgress(15, 'ƒêang x√≥a flash...');
                    addMonitorLine('üóëÔ∏è ƒêang x√≥a to√†n b·ªô flash memory...', 'info');
                    if (espWrapper) {
                        await espWrapper.eraseFlash();
                    } else {
                        addMonitorLine('‚ö†Ô∏è S·ª≠ d·ª•ng ph∆∞∆°ng ph√°p x√≥a c∆° b·∫£n...', 'warning');
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    }
                    addMonitorLine('‚úÖ ƒê√£ x√≥a flash xong.', 'success');
                    updateProgress(25, 'ƒê√£ x√≥a flash');
                }
                
                // Write flash using esptool-js (official implementation)
                updateProgress(30, 'ƒêang flash firmware...');
                addMonitorLine(`üì§ ƒêang ghi firmware v√†o ƒë·ªãa ch·ªâ ${address}...`, 'info');
                
                const flashAddress = parseInt(address, 16);
                const totalSize = firmwareData.length;
                let lastProgress = 0;
                let lastBytesWritten = 0;
                let lastTime = Date.now();
                
                // Use wrapper to call esptool-js writeFlash method
                if (espWrapper) {
                    await espWrapper.flashFirmware(flashAddress, firmwareData, flashParams, (bytesWritten, totalBytes) => {
                        const progress = (bytesWritten / totalBytes) * 100;
                        const progressPercent = 30 + (progress * 0.65);
                        updateProgress(progressPercent, `ƒêang ghi: ${Math.round(progress)}%`);
                        
                        // Calculate speed
                        const now = Date.now();
                        const timeDiff = (now - lastTime) / 1000; // seconds
                        const bytesDiff = bytesWritten - lastBytesWritten;
                        const speed = timeDiff > 0 ? (bytesDiff / timeDiff / 1024).toFixed(2) + ' KB/s' : '';
                        
                        // Update monitor every 5% or every 50KB or every 2 seconds
                        if (progress - lastProgress >= 5 || bytesDiff >= 51200 || timeDiff >= 2) {
                            addMonitorLine(
                                `üìä ƒê√£ ghi: ${(bytesWritten / 1024).toFixed(2)} KB / ${(totalBytes / 1024).toFixed(2)} KB (${Math.round(progress)}%) ${speed}`,
                                'info'
                            );
                            lastProgress = progress;
                            lastBytesWritten = bytesWritten;
                            lastTime = now;
                        }
                    });
                } else {
                    addMonitorLine('‚ùå L·ªói: esptool-js kh√¥ng kh·∫£ d·ª•ng. Vui l√≤ng t·∫£i l·∫°i trang.', 'error');
                    throw new Error('esptool-js kh√¥ng kh·∫£ d·ª•ng. Vui l√≤ng t·∫£i l·∫°i trang.');
                }
                
                updateProgress(95, 'ƒêang ho√†n t·∫•t...');
                addMonitorLine('‚úÖ Flash ho√†n t·∫•t, ƒëang reset chip...', 'info');
                
                // Reset chip
                if (espWrapper) {
                    await espWrapper.reset();
                } else {
                    // Fallback reset
                    await port.setSignals({ dataTerminalReady: false, requestToSend: false });
                    await new Promise(resolve => setTimeout(resolve, 100));
                    await port.setSignals({ dataTerminalReady: true, requestToSend: true });
                }
                
                updateProgress(100, 'Flash ho√†n t·∫•t!');
                addMonitorLine('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'success');
                addMonitorLine('üéâ Flash firmware th√†nh c√¥ng!', 'success');
                addMonitorLine('ESP32 ƒë√£ ƒë∆∞·ª£c reset v√† ƒëang ch·∫°y firmware m·ªõi.', 'info');
                showAlert('Flash firmware th√†nh c√¥ng!', 'success');
                
                setTimeout(() => {
                    document.getElementById('flashProgress').classList.remove('active');
                    document.getElementById('flashBtn').disabled = false;
                }, 3000);
                
            } catch (error) {
                addMonitorLine('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'error');
                addMonitorLine('‚ùå L·ªói: ' + error.message, 'error');
                if (error.stack) {
                    addMonitorLine('Chi ti·∫øt: ' + error.stack.split('\n')[0], 'error');
                }
                showAlert('L·ªói khi flash: ' + error.message, 'error');
                document.getElementById('flashProgress').classList.remove('active');
                document.getElementById('flashBtn').disabled = false;
            }
        }

        // Reset ESP32 to bootloader
        async function resetToBootloader() {
            // Set DTR and RTS to enter bootloader
            await port.setSignals({ dataTerminalReady: false, requestToSend: true });
            await new Promise(resolve => setTimeout(resolve, 100));
            await port.setSignals({ dataTerminalReady: true, requestToSend: false });
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        // Erase flash
        async function eraseFlash() {
            // Simplified erase - in real implementation, you'd need to send proper commands
            // This is a placeholder for the erase operation
            await new Promise(resolve => setTimeout(resolve, 2000));
        }

        // Write flash
        async function writeFlash(address, data, progressCallback) {
            const chunkSize = 1024;
            const totalChunks = Math.ceil(data.length / chunkSize);
            
            for (let i = 0; i < totalChunks; i++) {
                const start = i * chunkSize;
                const end = Math.min(start + chunkSize, data.length);
                const chunk = data.slice(start, end);
                
                // Send write command (simplified - real implementation needs proper protocol)
                // This is a placeholder - you'd need to implement the full esptool protocol
                await writer.write(chunk);
                
                const progress = (i / totalChunks) * 100;
                if (progressCallback) {
                    progressCallback(progress, `ƒêang ghi: ${Math.round(progress)}%`);
                } else {
                    updateProgress(30 + (progress * 0.6), `ƒêang ghi: ${Math.round(progress)}%`);
                }
            }
        }

        // Reset chip
        async function resetChip() {
            await port.setSignals({ dataTerminalReady: false, requestToSend: false });
            await new Promise(resolve => setTimeout(resolve, 100));
            await port.setSignals({ dataTerminalReady: true, requestToSend: true });
        }

        // Update progress
        function updateProgress(percent, message) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressFill').textContent = Math.round(percent) + '%';
            document.getElementById('progressMessage').textContent = message;
        }

        // Serial Monitor Functions
        // Variables already declared at top of script

        async function startMonitor() {
            if (!port || !port.readable) {
                console.log('Cannot start monitor: port not available');
                return;
            }
            
            // Stop existing monitor if running
            if (monitorReader) {
                try {
                    await monitorReader.cancel();
                    await monitorReader.releaseLock();
                } catch (e) {
                    console.log('Error stopping existing monitor:', e);
                }
            }
            
            monitorReading = true;
            monitorPaused = false;
            
            try {
                monitorReader = port.readable.getReader();
                const decoder = new TextDecoder();
                
                addMonitorLine('B·∫Øt ƒë·∫ßu ƒë·ªçc d·ªØ li·ªáu t·ª´ ESP32...', 'info');
                
                while (monitorReading) {
                    if (monitorPaused) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        continue;
                    }
                    
                    const { value, done } = await monitorReader.read();
                    if (done) break;
                    
                    monitorBytesReceived += value.length;
                    const text = decoder.decode(value, { stream: true });
                    
                    // Split by lines
                    const lines = text.split('\n');
                    for (let i = 0; i < lines.length - 1; i++) {
                        if (lines[i].trim()) {
                            addMonitorLine(lines[i], 'normal');
                        }
                    }
                    
                    // Update stats
                    const bytesReceivedEl = document.getElementById('monitorBytesReceived');
                    if (bytesReceivedEl) {
                        bytesReceivedEl.textContent = monitorBytesReceived;
                    }
                }
            } catch (error) {
                if (error.name !== 'NetworkError' && error.name !== 'AbortError') {
                    addMonitorLine('L·ªói ƒë·ªçc d·ªØ li·ªáu: ' + error.message, 'error');
                }
            } finally {
                if (monitorReader) {
                    try {
                        await monitorReader.releaseLock();
                    } catch (e) {
                        // Ignore
                    }
                    monitorReader = null;
                }
            }
        }

        function stopMonitor() {
            monitorReading = false;
            if (monitorReader) {
                monitorReader.cancel();
                monitorReader.releaseLock();
                monitorReader = null;
            }
        }

        function toggleMonitor() {
            monitorPaused = !monitorPaused;
            const btn = document.getElementById('monitorToggleBtn');
            if (btn) {
                btn.textContent = monitorPaused ? '‚ñ∂Ô∏è Ti·∫øp t·ª•c' : '‚è∏Ô∏è T·∫°m d·ª´ng';
            }
            addMonitorLine(monitorPaused ? 'Monitor ƒë√£ t·∫°m d·ª´ng' : 'Monitor ƒë√£ ti·∫øp t·ª•c', 'info');
        }

        function addMonitorLine(text, type = 'normal') {
            if (!text || !text.trim()) return;
            
            const container = document.getElementById('monitorContainer');
            if (!container) return; // Monitor section might not exist
            
            const line = document.createElement('div');
            line.className = 'monitor-line ' + type;
            
            // Escape HTML
            const escapedText = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            line.textContent = escapedText;
            container.appendChild(line);
            
            // Auto scroll to bottom
            container.scrollTop = container.scrollHeight;
            
            // Update line count
            monitorLineCount++;
            const lineCountEl = document.getElementById('monitorLineCount');
            if (lineCountEl) {
                lineCountEl.textContent = monitorLineCount;
            }
            
            // Limit lines to prevent memory issues
            if (container.children.length > 1000) {
                container.removeChild(container.firstChild);
            }
        }

        function clearMonitor() {
            const container = document.getElementById('monitorContainer');
            if (!container) return;
            
            container.innerHTML = '';
            monitorLineCount = 0;
            const lineCountEl = document.getElementById('monitorLineCount');
            if (lineCountEl) {
                lineCountEl.textContent = '0';
            }
            addMonitorLine('Monitor ƒë√£ ƒë∆∞·ª£c x√≥a.', 'info');
        }

        async function sendMonitorCommand() {
            const input = document.getElementById('monitorInput');
            if (!input) return;
            
            const command = input.value.trim();
            
            if (!command) return;
            if (!writer) {
                showAlert('Ch∆∞a k·∫øt n·ªëi serial!', 'error');
                return;
            }
            
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(command + '\n');
                await writer.write(data);
                
                monitorBytesSent += data.length;
                const bytesSentEl = document.getElementById('monitorBytesSent');
                if (bytesSentEl) {
                    bytesSentEl.textContent = monitorBytesSent;
                }
                
                addMonitorLine('> ' + command, 'info');
                input.value = '';
            } catch (error) {
                addMonitorLine('L·ªói g·ª≠i l·ªánh: ' + error.message, 'error');
            }
        }

        function handleMonitorKeyPress(event) {
            if (event.key === 'Enter') {
                sendMonitorCommand();
            }
        }

        // Erase flash only (separate function using esptool-js)
        async function eraseFlashOnly() {
            if (!port || !writer) {
                showAlert('Vui l√≤ng k·∫øt n·ªëi serial tr∆∞·ªõc!', 'error');
                return;
            }

            if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a to√†n b·ªô flash memory? Thao t√°c n√†y kh√¥ng th·ªÉ ho√†n t√°c!')) {
                return;
            }

            try {
                document.getElementById('eraseProgress').classList.add('active');
                document.getElementById('eraseBtn').disabled = true;
                
                updateEraseProgress(0, 'ƒêang x√≥a flash...');
                addMonitorLine('üóëÔ∏è B·∫Øt ƒë·∫ßu x√≥a flash...', 'info');
                
                // Use wrapper to call esptool-js eraseFlash method
                if (espWrapper) {
                    await espWrapper.eraseFlash();
                } else {
                    addMonitorLine('‚ö†Ô∏è esptool-js kh√¥ng kh·∫£ d·ª•ng', 'error');
                    throw new Error('esptool-js kh√¥ng kh·∫£ d·ª•ng');
                }
                
                updateEraseProgress(100, 'ƒê√£ x√≥a flash xong!');
                addMonitorLine('‚úÖ ƒê√£ x√≥a flash th√†nh c√¥ng!', 'success');
                showAlert('ƒê√£ x√≥a flash th√†nh c√¥ng!', 'success');
                
                setTimeout(() => {
                    document.getElementById('eraseProgress').classList.remove('active');
                    document.getElementById('eraseBtn').disabled = false;
                }, 3000);
                
            } catch (error) {
                addMonitorLine('‚ùå L·ªói khi x√≥a flash: ' + error.message, 'error');
                showAlert('L·ªói khi x√≥a flash: ' + error.message, 'error');
                document.getElementById('eraseProgress').classList.remove('active');
                document.getElementById('eraseBtn').disabled = false;
            }
        }

        function updateEraseProgress(percent, message) {
            const fill = document.getElementById('eraseProgressFill');
            const msg = document.getElementById('eraseProgressMessage');
            if (fill) fill.style.width = percent + '%';
            if (fill) fill.textContent = Math.round(percent) + '%';
            if (msg) msg.textContent = message;
        }

        // Show alert
        function showAlert(message, type) {
            const alert = document.getElementById('alert');
            if (!alert) return;
            
            alert.textContent = message;
            alert.className = `alert alert-${type} active`;
            
            setTimeout(() => {
                alert.classList.remove('active');
            }, 5000);
        }
    </script>
</body>
</html>

