<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Web Flasher - Flash Online</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 30px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 12px;
            border: 1px solid #e9ecef;
        }

        .section-title {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
            color: #667eea;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section-title::before {
            content: "‚óè";
            font-size: 0.8em;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #495057;
        }

        select, input[type="text"], input[type="number"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
            text-align: center;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .progress-container {
            margin-top: 20px;
            display: none;
        }

        .progress-container.active {
            display: block;
        }

        .progress-bar {
            width: 100%;
            height: 40px;
            background: #e9ecef;
            border-radius: 20px;
            overflow: hidden;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.5s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 1.1em;
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255,255,255,0.3),
                transparent
            );
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-message {
            margin-top: 15px;
            text-align: center;
            color: #495057;
            font-weight: 600;
            font-size: 1.05em;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .progress-details {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 0.9em;
            color: #6c757d;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            display: none;
        }

        .alert.active {
            display: block;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            padding: 12px;
            background: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-input-label:hover {
            border-color: #667eea;
            background: #e9ecef;
        }

        .file-name {
            margin-top: 10px;
            color: #667eea;
            font-weight: 500;
        }

        .serial-status {
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }

        .serial-status.active {
            display: block;
        }

        .serial-status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .serial-status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .monitor-section {
            margin-top: 30px;
        }

        .monitor-container {
            background: #1e1e1e;
            border-radius: 8px;
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .monitor-line {
            color: #d4d4d4;
            margin-bottom: 2px;
            word-wrap: break-word;
        }

        .monitor-line.error {
            color: #f48771;
        }

        .monitor-line.success {
            color: #4ec9b0;
        }

        .monitor-line.info {
            color: #569cd6;
        }

        .monitor-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .monitor-input {
            flex: 1;
            padding: 10px;
            background: #252526;
            border: 1px solid #3e3e42;
            border-radius: 4px;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
        }

        .monitor-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn-small {
            padding: 10px 20px;
            font-size: 0.9em;
        }

        .monitor-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            font-size: 0.85em;
            color: #6c757d;
        }

        .monitor-stats span {
            padding: 5px 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 15px;
            }

            .content {
                padding: 20px;
            }

            .header h1 {
                font-size: 2em;
            }

            .btn-group {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÄ ESP32 Web Flasher</h1>
            <p>Flash ESP32 tr·ª±c ti·∫øp t·ª´ tr√¨nh duy·ªát - Kh√¥ng c·∫ßn c√†i ƒë·∫∑t!</p>
        </div>

        <div class="content">
            <!-- Serial Connection Section -->
            <div class="section">
                <div class="section-title">K·∫øt n·ªëi Serial</div>
                <div id="serialStatus" class="serial-status"></div>
                <div class="form-group">
                    <label for="baud">Baud Rate:</label>
                    <select id="baud">
                        <option value="115200" selected>115200</option>
                        <option value="230400">230400</option>
                        <option value="460800">460800</option>
                        <option value="921600">921600</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="connectSerial()" id="connectBtn">
                        üîå K·∫øt n·ªëi Serial
                    </button>
                    <button class="btn btn-primary" onclick="disconnectSerial()" id="disconnectBtn" style="display: none;">
                        üîå Ng·∫Øt k·∫øt n·ªëi
                    </button>
                </div>
                <div class="alert alert-warning" id="browserWarning" style="display: none;">
                    <strong>‚ö†Ô∏è L∆∞u √Ω:</strong> Web Serial API ch·ªâ ho·∫°t ƒë·ªông tr√™n Chrome, Edge, Opera v√† c√°c tr√¨nh duy·ªát Chromium. 
                    C·∫ßn k·∫øt n·ªëi HTTPS ho·∫∑c localhost.
                </div>
            </div>

            <!-- Flash Firmware Section -->
            <div class="section">
                <div class="section-title">Flash Firmware</div>
                <div class="form-group">
                    <label for="firmwareFile">Ch·ªçn file firmware (.bin):</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="firmwareFile" accept=".bin" onchange="onFileSelect()">
                        <label for="firmwareFile" class="file-input-label">
                            üìÅ Click ƒë·ªÉ ch·ªçn file ho·∫∑c k√©o th·∫£ file v√†o ƒë√¢y
                        </label>
                    </div>
                    <div id="fileName" class="file-name"></div>
                </div>
                <div class="form-group">
                    <label for="address">ƒê·ªãa ch·ªâ Flash (hex):</label>
                    <input type="text" id="address" value="0x1000" placeholder="0x1000">
                </div>
                <div class="form-group">
                    <label for="flashMode">Flash Mode:</label>
                    <select id="flashMode">
                        <option value="qio">QIO</option>
                        <option value="qout">QOUT</option>
                        <option value="dio" selected>DIO</option>
                        <option value="dout">DOUT</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="flashSize">Flash Size:</label>
                    <select id="flashSize">
                        <option value="256KB">256KB</option>
                        <option value="512KB">512KB</option>
                        <option value="1MB">1MB</option>
                        <option value="2MB">2MB</option>
                        <option value="4MB" selected>4MB</option>
                        <option value="8MB">8MB</option>
                        <option value="16MB">16MB</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="flashFreq">Flash Frequency:</label>
                    <select id="flashFreq">
                        <option value="80m">80MHz</option>
                        <option value="60m">60MHz</option>
                        <option value="48m">48MHz</option>
                        <option value="40m" selected>40MHz</option>
                        <option value="30m">30MHz</option>
                        <option value="26m">26MHz</option>
                        <option value="24m">24MHz</option>
                        <option value="20m">20MHz</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="eraseAll" style="width: auto; margin-right: 8px;">
                        X√≥a to√†n b·ªô flash tr∆∞·ªõc khi flash
                    </label>
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="flashFirmware()" id="flashBtn" disabled>
                        ‚ö° Flash Firmware
                    </button>
                </div>
                <div id="flashProgress" class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill">0%</div>
                    </div>
                    <div class="progress-message" id="progressMessage"></div>
                </div>
            </div>

            <!-- Serial Monitor Section -->
            <div class="section monitor-section">
                <div class="section-title">üì∫ Serial Monitor</div>
                <div class="monitor-stats">
                    <span>üìä Lines: <span id="monitorLineCount">0</span></span>
                    <span>üì• Received: <span id="monitorBytesReceived">0</span> bytes</span>
                    <span>üì§ Sent: <span id="monitorBytesSent">0</span> bytes</span>
                </div>
                <div class="monitor-controls">
                    <input type="text" id="monitorInput" class="monitor-input" placeholder="Nh·∫≠p l·ªánh v√† nh·∫•n Enter ƒë·ªÉ g·ª≠i..." onkeypress="handleMonitorKeyPress(event)">
                    <button class="btn btn-primary btn-small" onclick="sendMonitorCommand()">üì§ G·ª≠i</button>
                    <button class="btn btn-primary btn-small" onclick="clearMonitor()">üóëÔ∏è X√≥a</button>
                    <button class="btn btn-primary btn-small" onclick="toggleMonitor()" id="monitorToggleBtn">‚è∏Ô∏è T·∫°m d·ª´ng</button>
                </div>
                <div id="monitorContainer" class="monitor-container">
                    <div class="monitor-line info">Serial Monitor s·∫µn s√†ng. K·∫øt n·ªëi ESP32 ƒë·ªÉ b·∫Øt ƒë·∫ßu...</div>
                </div>
            </div>

            <!-- Alert Messages -->
            <div id="alert" class="alert"></div>
        </div>
    </div>

    <!-- Use official esptool-js library from Espressif -->
    <script src="https://unpkg.com/esptool-js@1.0.0/dist/esptool.js"></script>
    <script>
        let port = null;
        let reader = null;
        let writer = null;
        let monitorReading = false;
        let monitorPaused = false;
        let monitorLineCount = 0;
        let monitorBytesReceived = 0;
        let monitorBytesSent = 0;
        let monitorReader = null;

        // Check browser support
        if (typeof navigator !== 'undefined' && !navigator.serial) {
            const warningEl = document.getElementById('browserWarning');
            if (warningEl) {
                warningEl.style.display = 'block';
            }
            // showAlert will be defined later, so we'll call it after DOM is ready
            setTimeout(() => {
                if (typeof showAlert === 'function') {
                    showAlert('Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ Web Serial API. Vui l√≤ng s·ª≠ d·ª•ng Chrome, Edge ho·∫∑c Opera.', 'error');
                }
            }, 100);
        }

        // ESPLoader instance from esptool-js
        let esploader = null;

        // Connect to serial port using esptool-js
        async function connectSerial() {
            try {
                if (!navigator.serial) {
                    showAlert('Web Serial API kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£ tr√™n tr√¨nh duy·ªát n√†y!', 'error');
                    return;
                }

                // Check if esptool-js is available
                if (typeof ESPLoader === 'undefined') {
                    showAlert('esptool-js ch∆∞a ƒë∆∞·ª£c t·∫£i. ƒêang t·∫£i l·∫°i trang...', 'error');
                    setTimeout(() => location.reload(), 2000);
                    return;
                }

                port = await navigator.serial.requestPort();
                const baud = parseInt(document.getElementById('baud').value);
                
                await port.open({ baudRate: baud });
                
                reader = port.readable.getReader();
                writer = port.writable.getWriter();

                // Initialize ESPLoader from esptool-js
                addMonitorLine('ƒêang kh·ªüi t·∫°o ESPLoader...', 'info');
                esploader = new ESPLoader(port, baud, {
                    trace: false,
                    debug: false
                });

                // Connect to ESP32
                addMonitorLine('ƒêang k·∫øt n·ªëi v·ªõi ESP32...', 'info');
                await esploader.connect();
                
                // Get chip info
                const chipInfo = esploader.chip;
                addMonitorLine(`ƒê√£ k·∫øt n·ªëi v·ªõi ${chipInfo.CHIP_NAME}`, 'success');
                addMonitorLine(`MAC: ${chipInfo.macAddress || 'N/A'}`, 'info');

                updateSerialStatus(true);
                document.getElementById('connectBtn').style.display = 'none';
                document.getElementById('disconnectBtn').style.display = 'inline-block';
                document.getElementById('flashBtn').disabled = false;
                document.getElementById('eraseBtn').disabled = false;
                
                // Start monitoring
                startMonitor();
                
                showAlert('ƒê√£ k·∫øt n·ªëi th√†nh c√¥ng v·ªõi ESP32!', 'success');
            } catch (error) {
                addMonitorLine('L·ªói k·∫øt n·ªëi: ' + error.message, 'error');
                if (error.name === 'NotFoundError') {
                    showAlert('Kh√¥ng t√¨m th·∫•y c·ªïng serial. Vui l√≤ng th·ª≠ l·∫°i.', 'error');
                } else {
                    showAlert('L·ªói k·∫øt n·ªëi: ' + error.message, 'error');
                }
            }
        }

        // Disconnect serial port
        async function disconnectSerial() {
            try {
                stopMonitor();
                
                // Close esptool-js connection
                if (esploader) {
                    try {
                        await esploader.disconnect();
                    } catch (e) {
                        console.log('Error disconnecting esploader:', e);
                    }
                    esploader = null;
                }
                
                if (reader) {
                    await reader.cancel();
                    await reader.releaseLock();
                }
                if (writer) {
                    await writer.releaseLock();
                }
                if (port) {
                    await port.close();
                }
                
                port = null;
                reader = null;
                writer = null;
                
                updateSerialStatus(false);
                document.getElementById('connectBtn').style.display = 'inline-block';
                document.getElementById('disconnectBtn').style.display = 'none';
                document.getElementById('flashBtn').disabled = true;
                
                addMonitorLine('ƒê√£ ng·∫Øt k·∫øt n·ªëi.', 'info');
                showAlert('ƒê√£ ng·∫Øt k·∫øt n·ªëi.', 'success');
            } catch (error) {
                showAlert('L·ªói khi ng·∫Øt k·∫øt n·ªëi: ' + error.message, 'error');
            }
        }

        // Update serial status
        function updateSerialStatus(connected) {
            const statusDiv = document.getElementById('serialStatus');
            statusDiv.classList.remove('connected', 'disconnected');
            statusDiv.classList.add(connected ? 'connected' : 'disconnected', 'active');
            statusDiv.textContent = connected ? '‚úÖ ƒê√£ k·∫øt n·ªëi' : '‚ùå Ch∆∞a k·∫øt n·ªëi';
        }

        // Handle file selection
        function onFileSelect() {
            const fileInput = document.getElementById('firmwareFile');
            const fileName = document.getElementById('fileName');
            
            if (fileInput.files.length > 0) {
                fileName.textContent = 'üìÑ ' + fileInput.files[0].name;
            } else {
                fileName.textContent = '';
            }
        }

        // Flash firmware
        async function flashFirmware() {
            if (!port || !writer) {
                showAlert('Vui l√≤ng k·∫øt n·ªëi serial tr∆∞·ªõc!', 'error');
                return;
            }

            const fileInput = document.getElementById('firmwareFile');
            if (!fileInput.files.length) {
                showAlert('Vui l√≤ng ch·ªçn file firmware!', 'error');
                return;
            }

            const address = document.getElementById('address').value;
            if (!/^0x[0-9A-Fa-f]+$/.test(address)) {
                showAlert('ƒê·ªãa ch·ªâ flash kh√¥ng h·ª£p l·ªá! Vui l√≤ng nh·∫≠p d·∫°ng hex (v√≠ d·ª•: 0x1000)', 'error');
                return;
            }

            const file = fileInput.files[0];
            const flashMode = document.getElementById('flashMode').value;
            const flashSize = document.getElementById('flashSize').value;
            const flashFreq = document.getElementById('flashFreq').value;
            const eraseAll = document.getElementById('eraseAll').checked;

            try {
                document.getElementById('flashProgress').classList.add('active');
                document.getElementById('flashBtn').disabled = true;
                
                updateProgress(0, 'ƒêang ƒë·ªçc file firmware...');
                
                const arrayBuffer = await file.arrayBuffer();
                const firmwareData = new Uint8Array(arrayBuffer);
                
                updateProgress(10, 'ƒêang k·∫øt n·ªëi v·ªõi ESP32...');
                addMonitorLine('B·∫Øt ƒë·∫ßu qu√° tr√¨nh flash firmware...', 'info');
                
                // Reset ESP32 into bootloader mode
                addMonitorLine('ƒêang reset ESP32 v√†o bootloader mode...', 'info');
                await resetToBootloader();
                
                updateProgress(20, 'ƒêang x√≥a flash...');
                if (eraseAll) {
                    addMonitorLine('ƒêang x√≥a to√†n b·ªô flash memory...', 'info');
                    await eraseFlash();
                    addMonitorLine('ƒê√£ x√≥a flash xong.', 'success');
                }
                
                updateProgress(30, 'ƒêang flash firmware...');
                addMonitorLine(`ƒêang ghi firmware v√†o ƒë·ªãa ch·ªâ ${address}...`, 'info');
                const totalSize = firmwareData.length;
                let written = 0;
                
                await writeFlash(parseInt(address, 16), firmwareData, (progress, msg) => {
                    updateProgress(30 + (progress * 0.6), msg);
                    written = Math.floor((progress / 100) * totalSize);
                    addMonitorLine(`ƒê√£ ghi: ${(written / 1024).toFixed(2)} KB / ${(totalSize / 1024).toFixed(2)} KB`, 'info');
                });
                
                updateProgress(90, 'ƒêang reset chip...');
                addMonitorLine('ƒêang reset ESP32...', 'info');
                await resetChip();
                
                updateProgress(100, 'Flash ho√†n t·∫•t!');
                addMonitorLine('‚úÖ Flash firmware th√†nh c√¥ng!', 'success');
                showAlert('Flash firmware th√†nh c√¥ng!', 'success');
                
                setTimeout(() => {
                    document.getElementById('flashProgress').classList.remove('active');
                    document.getElementById('flashBtn').disabled = false;
                }, 3000);
                
            } catch (error) {
                showAlert('L·ªói khi flash: ' + error.message, 'error');
                document.getElementById('flashProgress').classList.remove('active');
                document.getElementById('flashBtn').disabled = false;
            }
        }

        // Reset ESP32 to bootloader
        async function resetToBootloader() {
            // Set DTR and RTS to enter bootloader
            await port.setSignals({ dataTerminalReady: false, requestToSend: true });
            await new Promise(resolve => setTimeout(resolve, 100));
            await port.setSignals({ dataTerminalReady: true, requestToSend: false });
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        // Erase flash
        async function eraseFlash() {
            // Simplified erase - in real implementation, you'd need to send proper commands
            // This is a placeholder for the erase operation
            await new Promise(resolve => setTimeout(resolve, 2000));
        }

        // Write flash
        async function writeFlash(address, data, progressCallback) {
            const chunkSize = 1024;
            const totalChunks = Math.ceil(data.length / chunkSize);
            
            for (let i = 0; i < totalChunks; i++) {
                const start = i * chunkSize;
                const end = Math.min(start + chunkSize, data.length);
                const chunk = data.slice(start, end);
                
                // Send write command (simplified - real implementation needs proper protocol)
                // This is a placeholder - you'd need to implement the full esptool protocol
                await writer.write(chunk);
                
                const progress = (i / totalChunks) * 100;
                if (progressCallback) {
                    progressCallback(progress, `ƒêang ghi: ${Math.round(progress)}%`);
                } else {
                    updateProgress(30 + (progress * 0.6), `ƒêang ghi: ${Math.round(progress)}%`);
                }
            }
        }

        // Reset chip
        async function resetChip() {
            await port.setSignals({ dataTerminalReady: false, requestToSend: false });
            await new Promise(resolve => setTimeout(resolve, 100));
            await port.setSignals({ dataTerminalReady: true, requestToSend: true });
        }

        // Update progress
        function updateProgress(percent, message) {
            document.getElementById('progressFill').style.width = percent + '%';
            document.getElementById('progressFill').textContent = Math.round(percent) + '%';
            document.getElementById('progressMessage').textContent = message;
        }

        // Serial Monitor Functions
        // Variables already declared at top of script

        async function startMonitor() {
            if (!port || !port.readable) {
                console.log('Cannot start monitor: port not available');
                return;
            }
            
            // Stop existing monitor if running
            if (monitorReader) {
                try {
                    await monitorReader.cancel();
                    await monitorReader.releaseLock();
                } catch (e) {
                    console.log('Error stopping existing monitor:', e);
                }
            }
            
            monitorReading = true;
            monitorPaused = false;
            
            try {
                monitorReader = port.readable.getReader();
                const decoder = new TextDecoder();
                
                addMonitorLine('B·∫Øt ƒë·∫ßu ƒë·ªçc d·ªØ li·ªáu t·ª´ ESP32...', 'info');
                
                while (monitorReading) {
                    if (monitorPaused) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        continue;
                    }
                    
                    const { value, done } = await monitorReader.read();
                    if (done) break;
                    
                    monitorBytesReceived += value.length;
                    const text = decoder.decode(value, { stream: true });
                    
                    // Split by lines
                    const lines = text.split('\n');
                    for (let i = 0; i < lines.length - 1; i++) {
                        if (lines[i].trim()) {
                            addMonitorLine(lines[i], 'normal');
                        }
                    }
                    
                    // Update stats
                    const bytesReceivedEl = document.getElementById('monitorBytesReceived');
                    if (bytesReceivedEl) {
                        bytesReceivedEl.textContent = monitorBytesReceived;
                    }
                }
            } catch (error) {
                if (error.name !== 'NetworkError' && error.name !== 'AbortError') {
                    addMonitorLine('L·ªói ƒë·ªçc d·ªØ li·ªáu: ' + error.message, 'error');
                }
            } finally {
                if (monitorReader) {
                    try {
                        await monitorReader.releaseLock();
                    } catch (e) {
                        // Ignore
                    }
                    monitorReader = null;
                }
            }
        }

        function stopMonitor() {
            monitorReading = false;
            if (monitorReader) {
                monitorReader.cancel();
                monitorReader.releaseLock();
                monitorReader = null;
            }
        }

        function toggleMonitor() {
            monitorPaused = !monitorPaused;
            const btn = document.getElementById('monitorToggleBtn');
            if (btn) {
                btn.textContent = monitorPaused ? '‚ñ∂Ô∏è Ti·∫øp t·ª•c' : '‚è∏Ô∏è T·∫°m d·ª´ng';
            }
            addMonitorLine(monitorPaused ? 'Monitor ƒë√£ t·∫°m d·ª´ng' : 'Monitor ƒë√£ ti·∫øp t·ª•c', 'info');
        }

        function addMonitorLine(text, type = 'normal') {
            if (!text || !text.trim()) return;
            
            const container = document.getElementById('monitorContainer');
            if (!container) return; // Monitor section might not exist
            
            const line = document.createElement('div');
            line.className = 'monitor-line ' + type;
            
            // Escape HTML
            const escapedText = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
            
            line.textContent = escapedText;
            container.appendChild(line);
            
            // Auto scroll to bottom
            container.scrollTop = container.scrollHeight;
            
            // Update line count
            monitorLineCount++;
            const lineCountEl = document.getElementById('monitorLineCount');
            if (lineCountEl) {
                lineCountEl.textContent = monitorLineCount;
            }
            
            // Limit lines to prevent memory issues
            if (container.children.length > 1000) {
                container.removeChild(container.firstChild);
            }
        }

        function clearMonitor() {
            const container = document.getElementById('monitorContainer');
            if (!container) return;
            
            container.innerHTML = '';
            monitorLineCount = 0;
            const lineCountEl = document.getElementById('monitorLineCount');
            if (lineCountEl) {
                lineCountEl.textContent = '0';
            }
            addMonitorLine('Monitor ƒë√£ ƒë∆∞·ª£c x√≥a.', 'info');
        }

        async function sendMonitorCommand() {
            const input = document.getElementById('monitorInput');
            if (!input) return;
            
            const command = input.value.trim();
            
            if (!command) return;
            if (!writer) {
                showAlert('Ch∆∞a k·∫øt n·ªëi serial!', 'error');
                return;
            }
            
            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(command + '\n');
                await writer.write(data);
                
                monitorBytesSent += data.length;
                const bytesSentEl = document.getElementById('monitorBytesSent');
                if (bytesSentEl) {
                    bytesSentEl.textContent = monitorBytesSent;
                }
                
                addMonitorLine('> ' + command, 'info');
                input.value = '';
            } catch (error) {
                addMonitorLine('L·ªói g·ª≠i l·ªánh: ' + error.message, 'error');
            }
        }

        function handleMonitorKeyPress(event) {
            if (event.key === 'Enter') {
                sendMonitorCommand();
            }
        }

        // Show alert
        function showAlert(message, type) {
            const alert = document.getElementById('alert');
            if (!alert) return;
            
            alert.textContent = message;
            alert.className = `alert alert-${type} active`;
            
            setTimeout(() => {
                alert.classList.remove('active');
            }, 5000);
        }
    </script>
</body>
</html>

